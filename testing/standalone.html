<!DOCTYPE html>
<html>
<head>
    <title>Tests automation, theory and practice.</title>
    <meta charset="utf-8">
    <style>
        @import url("style.css");
    </style>
</head>
<body>
    <textarea id="source">

class: grey-background
layout: true

---
class: center, middle

# Tests automation, theory and practice.

---
# Test pyramid

![](./test_pyramid.png)

---
# Unit-testing

* Unit-testing is the main development assistant tool:

    * Coding simplification.

    * Less regression errors.

    * Easy debugging.

    * Reading and understanding your code is much easier for your colleagues.

    * System design (always) and architecture (sometimes) improvement.


.footnote[
__Think about system design, architecture AND your colleagues.__
]

---
# Unit-testing is simple... with Go

* Unit testing in Go significantly simpler than in C++ or many other languages because of:

    * Embedded unit-testing toolchain,

    * Packages.

    * Interfaces.

            * Circuit dependency ban.

.footnote[
__Unit-testing in Go is very simple.__
]

---
# What and how should you test with unit-tests?

* Tests target is object/package level behavior.

You can achieve it with:

* Mocking all external dependencies.

* Mocking all hardware level API.

* Testing results, but not internal functions calls sequence.

* Try to avoid timers and sleeps. If you must use them, make delays configurable.

.footnote[
__Unit-test development is NOT challenging or time consuming task!__
]

---
# Mocking external dependencies

Lets say we need to read something

```go
fn foo(SomeType dataSource) {
    buf := make([]byte, 5)
    data, err := dataSource.Read(buf)
    ...
}
```
--
Using exact type
```go
SomeType == File
```
--
Using interface
```go
type Reader interface {
    Read(p []byte) (n int, err error)
}
```
---
# Test results, but not internal functions calls sequence

The worst unit-test ever

```go
mockObj.EXPECT().SomeMethod_1("first")
mockObj.EXPECT().SomeMethod_2("second")
mockObj.EXPECT().SomeMethod_3("third")
...
mockObj.EXPECT().SomeMethod_1("fourth")
...
```

## Main issues:

* Function calls sequence testing instead of results testing.

* Hard-coded internal logic expectations.

---
# Good unit tests do

* Test results but not internal logic.

* Improves design and architecture.

* ???

---
# Coverage and automation


* Cover at least 75% of you code.

    * Applications with many low-level code difficult to cover.

    * 100% tests coverage is achievable, but too expensive.

* Prevent from unit tests coverage degradation.

    * Pipeline automation (Jenkins, TeamCity, Travis CI, etc.) allow to add coverage thresholds.

* Write set before or together with code, but not after.

    * improves code design a lot.
# Lets jump to IDE

---
# Fuzzing

* One of the most wonderful and often ignored type of tests.

* Very popular across DevSecOps.

* Helps you to cover all tricky parts in your code.

---
# How fuzzing looks

You need to write a test function of the form:

```go
func Fuzz(data []byte) int
```

Fuzzer:

* Generates random input.

* Monitors execution coverage.

* Monitors crashes/panics.

---
# Integration testing

![](./multy_tabs.svg)


    </textarea>
    <script src="http://gnab.github.io/remark/downloads/remark-latest.min.js" type="text/javascript"></script>
    <script type="text/javascript">
        var slideshow = remark.create();

    </script>
</body>
</html>
