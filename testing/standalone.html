<!DOCTYPE html>
<html>
<head>
    <title>Testing automation, theory and practice.</title>
    <meta charset="utf-8">
    <style>
        @import url("style.css");
    </style>
</head>
<body>
    <textarea id="source">

class: grey-background
layout: true

---
class: center, middle

# Testing automation, theory and practice.

---
# Test pyramid

![](./test_pyramid.png)

---
# Unit testing

* Unit-testing is the main development assistant tool:

    * Coding simplification.

    * Less regression errors.

    * Easy to debug your code.

    * Your colleagues can more easy read and understand your code.

    * Improve system design (always) and architecture (sometimes).

        * _We will talk about testing techniques that improve architecture a bit later._


.footnote[
__To think about system design, architecture AND your colleagues.__
]

---
# Unit-testing is simple... with Go

* Unit testing in Go significantly simpler than in C++ or many other languages because of:

    * Embedded unit-testing toolchain.

    * Packages AND

        * Interfaces AND

            * Circuit dependency ban.

.footnote[
__Unit-testing in Go is very simple.__
]

---
# What and how should you test with unit-tests?

* Tests target is object/package level behavior.

You can achieve it with:

* Mocking all external dependencies.

* Mocking all hardware level API.

* Testing results, but not internal functions calls sequence.

* Avoiding timers and sleeps. If it's impossible, make delays configurable.

.footnote[
__Unit-test development is not too big or too time consuming task!__
]

---
# Mocking external dependencies

Lets say we need to read something

```go
fn foo(SomeType dataSource) {
    buf := make([]byte, 5)
    data, err := dataSource.Read(buf)
    ...
}
```
--
Using exact type
```go
SomeType == File
```
--
Using interface
```go
type Reader interface {
    Read(p []byte) (n int, err error)
}
```
---
# Test results, but not internal functions calls sequence

The worst unit-test ever

```go
mockObj.EXPECT().SomeMethod_1("first")
mockObj.EXPECT().SomeMethod_2("second")
mockObj.EXPECT().SomeMethod_3("third")
...
mockObj.EXPECT().SomeMethod_1("fourth")
...
```

## Main issues:

* Function calls sequence testing instead of results testing.

* Hard-coded internal logic expectations.

---
# Good unit tests do

* Test results but not internal logic.

* Improves design and architecture.

* ???

---
# Coverage and automation


* Cover at least 75% of you code.

    * Applications with many low-level code difficult to cover.

    * 100% tests coverage is achievable, but too expensive.

* Prevent from unit tests coverage degradation.

    * Pipeline automation (Jenkins, TeamCity, Travis CI, etc.) allow to add coverage thresholds.

* Write set before or together with code, but not after.

    * improves code design a lot.

---
# Fuzzing

* One of the most wonderful and often ignored type of tests.

* Very popular across DevSecOps.

* Helps you to cover all tricky parts in your code.

---
# Fuzzing, how it looks like

You need to write a test function of the form:

```go
func Fuzz(data []byte) int
```

Fuzzer do:

* Generate random input.

* Monitor for execution coverage.

* Monitor for crashes/panics.
---
# Small demo

---
# Integration testing

![](./multy_tabs.svg)


    </textarea>
    <script src="http://gnab.github.io/remark/downloads/remark-latest.min.js" type="text/javascript"></script>
    <script type="text/javascript">
        var slideshow = remark.create();

    </script>
</body>
</html>
